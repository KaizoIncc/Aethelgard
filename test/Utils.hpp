#ifndef CRYPTO_UTILS_H
#define CRYPTO_UTILS_H

#include <sstream>
#include <iomanip>
#include <stdexcept>
#include <algorithm>
#include <mutex>
#include <unordered_map>
#include <string>
#include <vector>
#include <openssl/ec.h>
#include <openssl/ecdsa.h>
#include <openssl/obj_mac.h>
#include <openssl/sha.h>
#include <openssl/evp.h>
#include <openssl/pem.h>
#include <openssl/ripemd.h>
#include <openssl/rand.h>
#include <openssl/bio.h>
#include <openssl/buffer.h>
#include <openssl/bn.h>
#include <memory>
#include <chrono>
#include <iostream>

using namespace std;

class CryptoUtils {
public:
    // Hashing SHA-256
    /**
     * The function `CryptoUtils::sha256` converts a string input into a SHA-256 hash value.
     * 
     * @param data The `data` parameter is a constant reference to a string containing the input data for
     * which the SHA-256 hash needs to be calculated.
     * 
     * @return A SHA-256 hash of the input data is being returned.
     */
    static string sha256(const string& data);

    /**
     * The function `sha256` calculates the SHA-256 hash of a given vector of data.
     * 
     * @param data A vector of unsigned 8-bit integers representing the data for which you want to
     * calculate the SHA-256 hash.
     * 
     * @return The `CryptoUtils::sha256` function returns a hexadecimal string representation of the
     * SHA-256 hash of the input data provided in the form of a vector of unsigned 8-bit integers.
     */
    static string sha256(const vector<uint8_t>& data);
    
    // Generación de claves ECDSA (secp256k1 - misma curva que Bitcoin/Ethereum)
    /**
     * The function `generateKeyPair` in the `CryptoUtils` class generates a key pair and encodes them in
     * base64 format.
     * 
     * @param privateKey The `privateKey` parameter is a reference to a string where the generated private
     * key will be stored after encoding it in base64 format.
     * @param publicKey The `publicKey` parameter is a string that will store the public key generated by
     * the `generateKeyPair` function after encoding it in base64 format.
     * 
     * @return The `generateKeyPair` function returns a boolean value indicating whether the key pair
     * generation was successful or not. If successful, it returns `true`, and if unsuccessful, it returns
     * `false`.
     */
    static bool generateKeyPair(string& privateKey, string& publicKey);

    /**
     * The function `generateKeyPair` generates a key pair (private and public keys) using elliptic curve
     * cryptography.
     * 
     * @param privateKey The `privateKey` parameter is a vector of unsigned 8-bit integers (`uint8_t`) that
     * will store the generated private key bytes. The private key is typically a secret key used in
     * asymmetric cryptography for signing or decrypting data.
     * @param publicKey The `publicKey` parameter in the `generateKeyPair` function is a vector that will
     * store the generated public key bytes after the key pair generation process is completed. The public
     * key is derived from the private key using elliptic curve cryptography (ECC) and is represented as a
     * series of bytes
     * 
     * @return This function returns a boolean value indicating whether the key pair generation was
     * successful or not. If the key pair generation is successful, it returns true. If there are any
     * errors during the process, it returns false.
     */
    static bool generateKeyPair(vector<uint8_t>& privateKey, vector<uint8_t>& publicKey);
    
    // Firma digital
    /**
     * The function `signMessage` signs a message using a private key and returns the signature in base64
     * format.
     * 
     * @param privateKey The `privateKey` parameter is a string that represents the private key used for
     * signing the message.
     * @param message The `message` parameter is the content that you want to sign using the provided
     * private key. It could be any text or data that you want to ensure has not been tampered with and can
     * be verified using the corresponding public key.
     * 
     * @return The `signMessage` function in the `CryptoUtils` class takes a private key and a message as
     * input parameters, signs the message using the private key, and returns the signature of the message
     * encoded in base64 format.
     */
    static string signMessage(const string& privateKey, const string& message);

    /**
     * The `signMessage` function generates a digital signature for a given message using a private key in
     * C++ with the secp256k1 elliptic curve.
     * 
     * @param privateKey The `privateKey` parameter in the `signMessage` function is a vector of `uint8_t`
     * representing the private key used for signing the message. It is typically a binary representation
     * of the private key in a cryptographic algorithm like ECDSA (Elliptic Curve Digital Signature
     * Algorithm).
     * @param message The `message` parameter in the `signMessage` function is a vector of `uint8_t`
     * representing the message that you want to sign using the provided private key. This message will be
     * hashed using SHA-256 before being signed with the private key using the ECDSA algorithm.
     * 
     * @return The `signMessage` function returns a `vector<uint8_t>` containing the signature of the
     * message using the provided private key. If the signature generation is successful, the function
     * returns the signature bytes. If any error occurs during the process, an empty `vector<uint8_t>` is
     * returned.
     */
    static vector<uint8_t> signMessage(const vector<uint8_t>& privateKey, const vector<uint8_t>& message);
    
    // Verificación de firma
    /**
     * The function `verifySignature` decodes the public key, message, and signature from base64 format and
     * then verifies the signature using these decoded values.
     * 
     * @param publicKey The `publicKey` parameter is a string that represents the public key used for
     * verifying the signature.
     * @param message The `message` parameter in the `verifySignature` function is the content that has
     * been signed using a private key. It is typically a piece of data or a message that needs to be
     * verified using the corresponding public key and signature.
     * @param signature The `verifySignature` function you provided takes three parameters: `publicKey`,
     * `message`, and `signature`. In the context of verifying a signature, the `signature` parameter
     * typically represents the digital signature generated for a given `message` using a private key. The
     * function decodes the base64
     * 
     * @return The function `CryptoUtils::verifySignature` is returning a boolean value, which indicates
     * whether the signature for the given message and public key is valid or not.
     */
    static bool verifySignature(const string& publicKey, const string& message, const string& signature);

    /**
     * The function `verifySignature` in the `CryptoUtils` class verifies a signature using a public key
     * and a message using ECDSA with the secp256k1 curve.
     * 
     * @param publicKey The `publicKey` parameter in the `verifySignature` function is a vector of unsigned
     * 8-bit integers (`uint8_t`) representing the public key used for verifying the signature. It is
     * typically in the form of a byte array that encodes the public key in a specific format, such as
     * @param message The `message` parameter in the `verifySignature` function refers to the data that was
     * signed using a private key to generate the signature. This message is typically hashed before
     * signing to ensure data integrity and security. In the function, the message is hashed using the
     * SHA-256 algorithm before verifying the signature
     * @param signature The `signature` parameter in the `verifySignature` function is a vector of uint8_t
     * bytes that represents the signature of a message. It is used along with the public key and the
     * message to verify the authenticity and integrity of the message using ECDSA (Elliptic Curve Digital
     * Signature Algorithm).
     * 
     * @return The `verifySignature` function returns a boolean value (`true` or `false`) indicating
     * whether the signature verification was successful or not. If the verification is successful, it
     * returns `true`; otherwise, it returns `false`.
     */
    static bool verifySignature(const vector<uint8_t>& publicKey, const vector<uint8_t>& message, const vector<uint8_t>& signature);
    
    // Conversiones
    /**
     * The function `base64Encode` encodes a vector of uint8_t data into a base64 string.
     * 
     * @param data The `data` parameter in the `base64Encode` function is a vector of unsigned 8-bit
     * integers (`uint8_t`). This vector contains the binary data that you want to encode in Base64 format.
     * 
     * @return The function `CryptoUtils::base64Encode` returns a base64 encoded string representation of
     * the input data provided in the form of a vector of uint8_t.
     */
    static string base64Encode(const vector<uint8_t>& data);

    /**
     * The function `base64Decode` decodes a base64 encoded string into a vector of uint8_t.
     * 
     * @param encoded The `encoded` parameter in the `base64Decode` function is a `const string&` type,
     * which represents the base64 encoded string that you want to decode. This function decodes the base64
     * encoded string into a vector of `uint8_t` bytes and returns the decoded result.
     * 
     * @return A `vector<uint8_t>` containing the decoded data from the base64 encoded input string.
     */
    static vector<uint8_t> base64Decode(const string& encoded);

    /**
     * The function `hexEncode` converts a vector of uint8_t data into a hexadecimal string representation.
     * 
     * @param data The `data` parameter is a vector of unsigned 8-bit integers (`uint8_t`). This function
     * `hexEncode` takes this vector of bytes and encodes it into a hexadecimal string representation.
     * 
     * @return The `hexEncode` function returns a hexadecimal encoded string representation of the input
     * data, which is a vector of unsigned 8-bit integers (`vector<uint8_t>`).
     */
    static string hexEncode(const vector<uint8_t>& data);

    /**
     * The `hexDecode` function decodes a hexadecimal string into a vector of uint8_t bytes.
     * 
     * @param hex Thank you for providing the code snippet. Could you please provide an example hexadecimal
     * string that you would like to decode using the `hexDecode` function?
     * 
     * @return The `CryptoUtils::hexDecode` function returns a `vector<uint8_t>` containing the decoded
     * bytes from the input hexadecimal string.
     */
    static vector<uint8_t> hexDecode(const string& hex);
    
    // Utilidades de clave pública
    /**
     * The function `derivePublicKey` takes a private key in Base64 format, derives the corresponding
     * public key using the secp256k1 curve, and returns the public key encoded in Base64.
     * 
     * @param privateKeyBase64 The `derivePublicKey` function takes a private key encoded in Base64 as
     * input and derives the corresponding public key using elliptic curve cryptography (secp256k1).
     * 
     * @return The function `derivePublicKey` returns a string that represents the derived public key
     * encoded in Base64 format.
     */
    static string derivePublicKey(const string& privateKeyBase64);

    /**
     * The function `getAddressFromPublicKey` decodes a base64 public key and returns an address derived
     * from it.
     * 
     * @param publicKey It looks like the `getAddressFromPublicKey` function in the `CryptoUtils` class
     * takes a base64 encoded public key as input and returns an address. The `getAddressFromPublicKey`
     * function first decodes the base64 encoded public key into a vector of uint8_t and then calls another
     * 
     * @return The `getAddressFromPublicKey` function is being called with the `pubKey` vector as an
     * argument, and the result of this function call is being returned.
     */
    static string getAddressFromPublicKey(const string& publicKey);

    /**
     * The function `getAddressFromPublicKey` generates a cryptocurrency address from a given public key
     * using SHA-256 and RIPEMD-160 hashing algorithms.
     * 
     * @param publicKey A vector of uint8_t representing a public key. The function
     * `getAddressFromPublicKey` takes this public key, performs some cryptographic operations on it, and
     * returns a string representation of the resulting address.
     * 
     * @return The `getAddressFromPublicKey` function returns a string that represents the address derived
     * from a public key using SHA-256 and RIPEMD-160 hashing algorithms. The address is obtained by taking
     * the last 20 bytes of the RIPEMD-160 hash of the SHA-256 hash of the public key (excluding the first
     * byte that indicates compression).
     */
    static string getAddressFromPublicKey(const vector<uint8_t>& publicKey);

    /**
     * The function `publicKeyToAddress` converts a given public key in Base64 format to a corresponding
     * address using SHA-256 and RIPEMD-160 hashing algorithms.
     * 
     * @param publicKeyBase64 The `publicKeyToAddress` function you provided takes a Base64 encoded public
     * key as input and performs a series of cryptographic operations to derive an address. To use this
     * function, you need to provide a Base64 encoded public key as the `publicKeyBase64` parameter.
     * 
     * @return The `publicKeyToAddress` function returns a hexadecimal string that represents the address
     * derived from the given public key after performing Base64 decoding, SHA-256 hashing, and RIPEMD-160
     * hashing on it.
     */
    static string publicKeyToAddress(const string& publicKeyBase64);

    /**
     * The function `isValidAddress` checks if a given address is a valid crypto address by decoding it
     * from base64 and verifying its size.
     * 
     * @param address The `address` parameter is a string representing a cryptocurrency address that needs
     * to be validated. The `isValidAddress` function attempts to decode the base64-encoded address and
     * checks if the decoded data has a size of 20 bytes, which is typical for a cryptocurrency address
     * represented as a hash of a public
     * 
     * @return The `isValidAddress` function returns a boolean value. It returns `true` if the decoded
     * address is of the expected size (20 bytes) after decoding from base64, and `false` if an exception
     * is caught during the decoding process.
     */
    static bool isValidAddress(const string& addr);
    
    // Validación
    /**
     * The function `isValidPrivateKey` checks if a given private key is valid for the secp256k1 curve by
     * decoding it from Base64, verifying its size, and checking if it falls within the valid range.
     * 
     * @param privateKey The `isValidPrivateKey` function in the provided code snippet is used to validate
     * a private key for a cryptographic algorithm. The function performs the following steps:
     * 
     * @return The `isValidPrivateKey` function returns a boolean value indicating whether the provided
     * private key is valid or not. If the private key meets the specified criteria (correct length, within
     * valid range), the function returns `true`. Otherwise, it returns `false`.
     */
    static bool isValidPrivateKey(const string& privateKey);

    /**
     * The function `isValidPublicKey` in the `CryptoUtils` class validates a given public key encoded in
     * Base64 format for the secp256k1 curve.
     * 
     * @param publicKey The `isValidPublicKey` function in the provided code snippet is used to validate a
     * public key in the context of cryptography. The function performs the following steps to validate the
     * public key:
     * 
     * @return The `isValidPublicKey` function returns a boolean value indicating whether the provided
     * public key is valid according to the specified criteria. If the public key meets all the conditions
     * (correct length, format, and is a valid point on the curve), the function returns `true`. Otherwise,
     * it returns `false`.
     */
    static bool isValidPublicKey(const string& publicKey);
    
    /**
     * The function `clearCaches` clears various caches related to cryptographic key pairs and public keys,
     * and prints out the number of items freed.
     */
    static void clearCaches();

    /**
     * The function `getCachedPublicKey` retrieves a cached public key from a map or generates a new one if
     * not found.
     * 
     * @param publicKey The `getCachedPublicKey` function takes a vector of unsigned 8-bit integers
     * (`uint8_t`) named `publicKey` as input. This vector represents the public key in binary form that
     * will be used to retrieve or generate an EC_KEY object.
     * 
     * @return The function `getCachedPublicKey` returns an `EC_KEY*` pointer to the public key
     * corresponding to the input `publicKey` vector. If the public key is found in the cache, it returns
     * the cached `EC_KEY*` pointer. If not found in the cache, it constructs the `EC_KEY*` pointer from
     * the input public key data, caches it, and then returns the
     */
    static EC_KEY* getCachedPublicKey(const vector<uint8_t>& publicKey);
    
private:
    // Helper functions
    /**
     * The function creates a new EC key using the secp256k1 curve.
     * 
     * @return The function `createECKey` is returning a pointer to an `EC_KEY` structure.
     */
    static EC_KEY* createECKey();

    /**
     * The function generates a key pair for elliptic curve cryptography using the provided EC_KEY object.
     * 
     * @param ecKey The `ecKey` parameter is a pointer to an `EC_KEY` structure, which is used to represent
     * an elliptic curve cryptographic key pair in OpenSSL. The `generateKeyPair` function takes this
     * pointer as input and generates a new key pair using the `EC_KEY_generate_key` function provided
     * 
     * @return The function `CryptoUtils::generateKeyPair` returns a boolean value. It returns `true` if
     * the key pair generation was successful (`EC_KEY_generate_key(ecKey)` returns 1), and `false`
     * otherwise.
     */
    static bool generateKeyPair(EC_KEY* ecKey);
};

#endif // CRYPTO_UTILS_H